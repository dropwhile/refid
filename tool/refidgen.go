package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

const tagFileTplText = `
// Code generated by refidgen. DO NOT EDIT.
// generated from: {{.Origin}}

package {{.Pkg}}

import (
	"fmt"

	"github.com/dropwhile/refid"
)

const tagIDt{{.Number}} = {{.Number}}

type IDt{{.Number}} struct {
	refid.ID
}

func (r *IDt{{.Number}}) Validate(err error) error {
	if err != nil {
		return err
	}
	if !r.ID.HasTag(tagIDt{{.Number}}) {
		return fmt.Errorf("wrong refid type")
	}
	return nil
}

func (r *IDt{{.Number}}) Scan(src interface{}) error {
	err := r.ID.Scan(src)
	return r.Validate(err)
}

func (r *IDt{{.Number}}) UnmarshalJSON(b []byte) error {
	err := r.ID.UnmarshalJSON(b)
	return r.Validate(err)
}

func (r *IDt{{.Number}}) UnmarshalBinary(b []byte) error {
	err := r.ID.UnmarshalBinary(b)
	return r.Validate(err)
}

func (r *IDt{{.Number}}) UnmarshalText(b []byte) error {
	err := r.ID.UnmarshalText(b)
	return r.Validate(err)
}

func (r IDt{{.Number}}) toID() refid.ID {
	return r.ID
}

func (r IDt{{.Number}}) tagVal() byte {
	return tagIDt{{.Number}}
}

type NullIDt{{.Number}} struct {
	refid.NullID
}

func (u *NullIDt{{.Number}}) Validate(err error) error {
	if err != nil {
		return err
	}
	n := u.NullID
	if n.Valid && !n.ID.HasTag(tagIDt{{.Number}}) {
		return fmt.Errorf("wrong refid type")
	}
	return nil
}

func (u *NullIDt{{.Number}}) Scan(src interface{}) error {
	err := u.NullID.Scan(src)
	return u.Validate(err)
}

func (u *NullIDt{{.Number}}) UnmarshalJSON(b []byte) error {
	err := u.NullID.UnmarshalJSON(b)
	return u.Validate(err)
}
`

func main() {
	var suffix string
	flag.StringVar(&suffix, "s", ".gen.go", "file suffix")
	flag.Parse()

	fname := strings.TrimSuffix(os.Getenv("GOFILE"), ".go")
	pkg := os.Getenv("GOPACKAGE")

	if suffix == "" {
		log.Fatal("Param suffix is required")
	}

	t, err := template.New("fileTemplate").Parse(strings.TrimLeft(tagFileTplText, "\n"))
	if err != nil {
		log.Fatal(err)
	}

	for i := 1; i < 256; i++ {
		outname := fmt.Sprintf("%s_%d%s", fname, i, suffix)
		vars := map[string]any{
			"Number": i,
			"Origin": os.Getenv("GOFILE"),
			"Pkg":    pkg,
		}
		err := writeFile(t, outname, vars)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func writeFile(t *template.Template, outfile string, vars map[string]any) error {
	fmt.Printf("generating %s\n", outfile)
	w, err := os.Create(outfile)
	if err != nil {
		return err
	}
	defer w.Close()
	writer := bufio.NewWriter(w)
	defer writer.Flush()
	return t.Execute(writer, vars)
}
